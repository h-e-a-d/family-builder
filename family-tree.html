<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Family Tree Builder Pro</title>
    <style>
        * { box-sizing: border-box; }
        
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            background: #f5f5f5;
        }
        
        /* Controls Panel */
        #controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            padding: 15px;
            background: linear-gradient(135deg, #fff 0%, #f8f9fa 100%);
            border-bottom: 2px solid #dee2e6;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        /* Buttons */
        button {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(52, 152, 219, 0.3);
        }
        
        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(52, 152, 219, 0.4);
        }
        
        button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        /* Button Variants */
        .btn-danger { background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); }
        .btn-success { background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%); }
        .btn-warning { background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%); }
        .btn-secondary { background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%); }
        
        /* Inputs */
        input, select {
            padding: 8px 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            transition: border-color 0.3s;
        }
        
        input:focus, select:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }
        
        input[type="color"] {
            width: 50px;
            height: 38px;
            padding: 2px;
            cursor: pointer;
        }
        
        input[type="number"] {
            width: 70px;
        }
        
        /* Labels */
        label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-weight: 500;
            color: #495057;
            font-size: 13px;
        }
        
        /* SVG Canvas */
        #svgArea {
            width: 100%;
            height: calc(100vh - 90px);
            background: radial-gradient(circle at 50% 50%, #f8f9fa 0%, #e9ecef 100%);
            cursor: default;
            touch-action: none;
            border-top: 1px solid #dee2e6;
        }
        
        /* Person Styling */
        circle.person {
            cursor: grab;
            transition: all 0.3s ease;
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.2));
        }
        
        circle.person:hover {
            filter: drop-shadow(3px 3px 6px rgba(0,0,0,0.3));
            transform: scale(1.02);
        }
        
        circle.person.selected {
            stroke: #e74c3c !important;
            stroke-width: 4px !important;
            filter: drop-shadow(0 0 10px rgba(231, 76, 60, 0.5));
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { stroke-width: 4px; }
            50% { stroke-width: 6px; }
        }
        
        circle.person:active {
            cursor: grabbing;
        }
        
        /* Text Styling */
        text {
            font-family: Arial, sans-serif;
            pointer-events: none;
            user-select: none;
            text-anchor: middle;
        }
        
        text.name {
            font-weight: bold;
            fill: #2c3e50;
            font-size: 12px;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.8);
        }
        
        text.date {
            font-size: 10px;
            fill: #7f8c8d;
            font-style: italic;
        }
        
        /* Relationship Lines */
        line.relation {
            stroke: #555;
            stroke-width: 3;
            stroke-linecap: round;
            cursor: pointer;
            transition: all 0.2s ease;
            filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.1));
        }
        
        line.relation:hover {
            stroke: #e74c3c;
            stroke-width: 4px;
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.2));
        }
        
        /* Modal Styling */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            z-index: 1000;
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            animation: modalAppear 0.3s ease;
        }
        
        @keyframes modalAppear {
            from {
                opacity: 0;
                transform: translate(-50%, -60%);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid #f8f9fa;
        }
        
        .modal-header h3 {
            margin: 0;
            color: #2c3e50;
            font-size: 24px;
        }
        
        .close-btn {
            background: #95a5a6;
            padding: 8px 12px;
            font-size: 18px;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Form Styling */
        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .form-group {
            display: flex;
            flex-direction: column;
        }
        
        .form-group.full {
            grid-column: 1 / -1;
        }
        
        .form-group label {
            margin-bottom: 5px;
            font-weight: bold;
            color: #2c3e50;
            font-size: 14px;
        }
        
        .form-group input,
        .form-group select,
        .form-group textarea {
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            font-family: inherit;
            transition: border-color 0.3s;
        }
        
        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }
        
        .form-group textarea {
            resize: vertical;
            min-height: 80px;
        }
        
        .form-actions {
            display: flex;
            justify-content: flex-end;
            gap: 15px;
            margin-top: 25px;
            padding-top: 20px;
            border-top: 2px solid #f8f9fa;
        }
        
        .form-actions button {
            min-width: 100px;
            padding: 12px 20px;
            font-size: 16px;
        }
        
        /* Status Bar */
        .status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
            color: white;
            padding: 8px 20px;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 99;
            border-top: 1px solid #1a252f;
        }
        
        /* Toast Notifications */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            font-weight: 500;
            transform: translateX(100%);
            transition: transform 0.4s ease;
            max-width: 300px;
        }
        
        .toast.show {
            transform: translateX(0);
        }
        
        .toast.error {
            background: linear-gradient(135deg, #c0392b 0%, #e74c3c 100%);
        }
        
        .toast.warning {
            background: linear-gradient(135deg, #e67e22 0%, #f39c12 100%);
        }
        
        .toast.info {
            background: linear-gradient(135deg, #2980b9 0%, #3498db 100%);
        }
        
        /* Search Input */
        #searchInput {
            flex: 1;
            max-width: 200px;
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 20px;
            font-size: 14px;
            background: white;
        }
        
        #searchInput::placeholder {
            color: #999;
            font-style: italic;
        }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            #controls {
                grid-template-columns: 1fr;
                gap: 8px;
            }
            
            .form-row {
                grid-template-columns: 1fr;
            }
            
            .modal-content {
                width: 95%;
                padding: 20px;
            }
            
            button {
                padding: 12px 15px;
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <!-- Controls Panel -->
    <div id="controls">
        <!-- Person Management -->
        <button id="addPersonBtn">➕ Add Person</button>
        <button id="editBtn" disabled>✏️ Edit</button>
        <button id="deleteBtn" class="btn-danger" disabled>🗑️ Delete</button>
        
        <!-- Connection -->
        <button id="connectBtn" class="btn-warning">🔗 Connect</button>
        
        <!-- Appearance -->
        <label>Color: <input type="color" id="colorPicker" value="#3498db" disabled></label>
        <label>Size: <input type="number" id="sizeInput" min="20" max="80" value="40" disabled></label>
        <button id="applyBtn" disabled>Apply</button>
        
        <!-- Search -->
        <input type="text" id="searchInput" placeholder="🔍 Search people...">
        <button id="clearSearchBtn" class="btn-secondary">Clear</button>
        
        <!-- Actions -->
        <button id="centerBtn" class="btn-success">🎯 Center</button>
        <button id="undoBtn" class="btn-secondary" disabled>↶ Undo</button>
        
        <!-- File Management -->
        <button id="saveBtn" class="btn-success">💾 Save</button>
        <input type="file" id="loadInput" accept=".json" style="display: none;">
        <button onclick="document.getElementById('loadInput').click()">📁 Load</button>
        
        <!-- Export -->
        <button id="exportSvgBtn" class="btn-warning">📄 Export SVG</button>
        <button id="exportPngBtn" class="btn-warning">🖼️ Export PNG</button>
        <button id="exportPdfBtn" class="btn-warning">📑 Export PDF</button>
        
        <!-- Font Controls -->
        <label>Font: 
            <select id="fontSelect">
                <option value="Arial, sans-serif">Arial</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="Times New Roman, serif">Times New Roman</option>
                <option value="Courier New, monospace">Courier New</option>
                <option value="Verdana, sans-serif">Verdana</option>
                <option value="Comic Sans MS, cursive">Comic Sans</option>
            </select>
        </label>
        <label>Font Size: 
            <input type="number" id="fontSizeInput" min="8" max="24" value="12">
        </label>
    </div>

    <!-- Main Canvas -->
    <svg id="svgArea" xmlns="http://www.w3.org/2000/svg"></svg>

    <!-- Person Modal -->
    <div id="personModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modalTitle">Add Person</h3>
                <button class="close-btn" onclick="closePersonModal()">×</button>
            </div>
            
            <form id="personForm">
                <div class="form-row">
                    <div class="form-group">
                        <label for="firstName">First Name *</label>
                        <input type="text" id="firstName" required>
                    </div>
                    <div class="form-group">
                        <label for="lastName">Last Name *</label>
                        <input type="text" id="lastName" required>
                    </div>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="birthDate">Birth Date</label>
                        <input type="date" id="birthDate">
                    </div>
                    <div class="form-group">
                        <label for="gender">Gender</label>
                        <select id="gender">
                            <option value="unknown">Unknown</option>
                            <option value="male">Male</option>
                            <option value="female">Female</option>
                            <option value="other">Other</option>
                        </select>
                    </div>
                </div>
                
                <div class="form-row">
                    <div class="form-group full">
                        <label for="birthPlace">Birth Place</label>
                        <input type="text" id="birthPlace">
                    </div>
                </div>
                
                <div class="form-row">
                    <div class="form-group full">
                        <label for="occupation">Occupation</label>
                        <input type="text" id="occupation">
                    </div>
                </div>
                
                <div class="form-row">
                    <div class="form-group full">
                        <label for="notes">Notes</label>
                        <textarea id="notes" rows="3"></textarea>
                    </div>
                </div>
                
                <div class="form-actions">
                    <button type="button" class="btn-secondary" onclick="closePersonModal()">Cancel</button>
                    <button type="submit">Save Person</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Status Bar -->
    <div class="status-bar">
        <span id="peopleCount">0 people</span>
        <span id="relationshipsCount">0 relationships</span>
        <span id="selectedInfo">No selection</span>
        <span id="zoomLevel">100%</span>
    </div>

    <script>
        // =============================================================================
        // FAMILY TREE BUILDER - CLEAN VERSION
        // =============================================================================
        
        console.log('🌳 Family Tree Builder Pro - Starting initialization...');
        
        // Global State
        const state = {
            people: new Map(),
            relationships: new Map(),
            selected: null,
            connectMode: false,
            personCount: 0,
            viewBox: { x: 0, y: 0, w: 800, h: 600 },
            history: [],
            searchMatches: new Set(),
            globalFont: 'Arial, sans-serif',
            globalFontSize: 12
        };
        
        // DOM Elements
        const elements = {
            svg: document.getElementById('svgArea'),
            addPersonBtn: document.getElementById('addPersonBtn'),
            editBtn: document.getElementById('editBtn'),
            deleteBtn: document.getElementById('deleteBtn'),
            connectBtn: document.getElementById('connectBtn'),
            colorPicker: document.getElementById('colorPicker'),
            sizeInput: document.getElementById('sizeInput'),
            applyBtn: document.getElementById('applyBtn'),
            searchInput: document.getElementById('searchInput'),
            clearSearchBtn: document.getElementById('clearSearchBtn'),
            centerBtn: document.getElementById('centerBtn'),
            undoBtn: document.getElementById('undoBtn'),
            saveBtn: document.getElementById('saveBtn'),
            loadInput: document.getElementById('loadInput'),
            exportSvgBtn: document.getElementById('exportSvgBtn'),
            exportPngBtn: document.getElementById('exportPngBtn'),
            exportPdfBtn: document.getElementById('exportPdfBtn'),
            fontSelect: document.getElementById('fontSelect'),
            fontSizeInput: document.getElementById('fontSizeInput'),
            personModal: document.getElementById('personModal'),
            personForm: document.getElementById('personForm')
        };
        
        // =============================================================================
        // INITIALIZATION
        // =============================================================================
        
        function init() {
            console.log('Setting up Family Tree Builder...');
            
            updateViewBox();
            createBackground();
            setupEventListeners();
            updateStatusBar();
            
            console.log('✅ Family Tree Builder initialized successfully!');
            showToast('Family Tree Builder loaded! Click "Add Person" to start.', 'info');
        }
        
        function updateViewBox() {
            elements.svg.setAttribute('viewBox', `${state.viewBox.x} ${state.viewBox.y} ${state.viewBox.w} ${state.viewBox.h}`);
            updateZoomLevel();
        }
        
        function createBackground() {
            // Create grid background
            const gridSize = 50;
            const extent = 2000;
            
            for (let x = -extent; x <= extent; x += gridSize) {
                const line = document.createElementNS(elements.svg.namespaceURI, 'line');
                line.setAttribute('x1', x);
                line.setAttribute('y1', -extent);
                line.setAttribute('x2', x);
                line.setAttribute('y2', extent);
                line.setAttribute('stroke', '#e0e0e0');
                line.setAttribute('stroke-width', '0.5');
                line.setAttribute('opacity', '0.3');
                line.setAttribute('class', 'grid-line');
                elements.svg.appendChild(line);
            }
            
            for (let y = -extent; y <= extent; y += gridSize) {
                const line = document.createElementNS(elements.svg.namespaceURI, 'line');
                line.setAttribute('x1', -extent);
                line.setAttribute('y1', y);
                line.setAttribute('x2', extent);
                line.setAttribute('y2', y);
                line.setAttribute('stroke', '#e0e0e0');
                line.setAttribute('stroke-width', '0.5');
                line.setAttribute('opacity', '0.3');
                line.setAttribute('class', 'grid-line');
                elements.svg.appendChild(line);
            }
        }
        
        // =============================================================================
        // EVENT LISTENERS
        // =============================================================================
        
        function setupEventListeners() {
            console.log('Setting up event listeners...');
            
            // Person Management
            elements.addPersonBtn.addEventListener('click', () => {
                console.log('Add Person button clicked');
                openPersonModal();
            });
            
            elements.editBtn.addEventListener('click', () => {
                if (state.selected) {
                    openPersonModal(state.selected);
                }
            });
            
            elements.deleteBtn.addEventListener('click', () => {
                if (state.selected && confirm('Are you sure you want to delete this person?')) {
                    deletePerson(state.selected);
                }
            });
            
            // Connection
            elements.connectBtn.addEventListener('click', toggleConnectMode);
            
            // Appearance
            elements.applyBtn.addEventListener('click', applyChanges);
            
            // Search
            elements.searchInput.addEventListener('input', (e) => performSearch(e.target.value));
            elements.clearSearchBtn.addEventListener('click', clearSearch);
            
            // Actions
            elements.centerBtn.addEventListener('click', centerView);
            elements.undoBtn.addEventListener('click', undo);
            
            // File Management
            elements.saveBtn.addEventListener('click', saveTree);
            elements.loadInput.addEventListener('change', loadTree);
            elements.exportSvgBtn.addEventListener('click', exportSVG);
            elements.exportPngBtn.addEventListener('click', exportPNG);
            elements.exportPdfBtn.addEventListener('click', exportPDF);
            
            // Font Controls
            elements.fontSelect.addEventListener('change', updateGlobalFont);
            elements.fontSizeInput.addEventListener('change', updateGlobalFontSize);
            
            // Form Submission
            elements.personForm.addEventListener('submit', handleFormSubmit);
            
            // SVG Interactions
            elements.svg.addEventListener('click', (e) => {
                if (e.target === elements.svg || e.target.classList.contains('grid-line')) {
                    clearSelection();
                }
            });
            
            // Pan and Zoom
            setupPanAndZoom();
            
            // Keyboard Shortcuts
            setupKeyboardShortcuts();
            
            console.log('✅ Event listeners setup complete');
        }
        
        // =============================================================================
        // PERSON MANAGEMENT
        // =============================================================================
        
        function openPersonModal(circle = null) {
            console.log('Opening person modal', circle ? '(edit mode)' : '(add mode)');
            
            const title = document.getElementById('modalTitle');
            
            // Clear form
            elements.personForm.reset();
            
            if (circle) {
                // Edit mode
                title.textContent = 'Edit Person';
                const person = state.people.get(circle.dataset.personId);
                
                if (person) {
                    document.getElementById('firstName').value = person.firstName || '';
                    document.getElementById('lastName').value = person.lastName || '';
                    document.getElementById('birthDate').value = person.birthDate || '';
                    document.getElementById('gender').value = person.gender || 'unknown';
                    document.getElementById('birthPlace').value = person.birthPlace || '';
                    document.getElementById('occupation').value = person.occupation || '';
                    document.getElementById('notes').value = person.notes || '';
                }
            } else {
                // Add mode
                title.textContent = 'Add Person';
            }
            
            elements.personModal.style.display = 'block';
            setTimeout(() => {
                document.getElementById('firstName').focus();
            }, 100);
        }
        
        function closePersonModal() {
            console.log('Closing person modal');
            elements.personModal.style.display = 'none';
        }
        
        function handleFormSubmit(e) {
            e.preventDefault();
            console.log('Form submitted');
            
            const formData = {
                firstName: document.getElementById('firstName').value.trim(),
                lastName: document.getElementById('lastName').value.trim(),
                birthDate: document.getElementById('birthDate').value,
                gender: document.getElementById('gender').value,
                birthPlace: document.getElementById('birthPlace').value.trim(),
                occupation: document.getElementById('occupation').value.trim(),
                notes: document.getElementById('notes').value.trim()
            };
            
            console.log('Form data:', formData);
            
            // Validation
            if (!formData.firstName || !formData.lastName) {
                showToast('Please enter both first name and last name', 'error');
                return;
            }
            
            if (state.selected) {
                // Edit existing person
                updatePerson(state.selected, formData);
                showToast('Person updated successfully!', 'success');
            } else {
                // Create new person
                createPerson(formData);
                showToast('Person added successfully!', 'success');
            }
            
            closePersonModal();
            updateStatusBar();
            pushHistory();
        }
        
        function createPerson(data) {
            const personId = 'person_' + (++state.personCount);
            const cx = state.viewBox.x + state.viewBox.w / 2 + (Math.random() - 0.5) * 200;
            const cy = state.viewBox.y + state.viewBox.h / 2 + (Math.random() - 0.5) * 200;
            
            console.log(`Creating person: ${data.firstName} ${data.lastName} at (${cx}, ${cy})`);
            
            // Store person data
            const person = {
                id: personId,
                ...data,
                x: cx,
                y: cy,
                color: elements.colorPicker.value,
                size: parseInt(elements.sizeInput.value)
            };
            
            state.people.set(personId, person);
            
            // Create visual element
            const circle = createPersonElement(person);
            
            console.log(`✅ Person created: ${person.firstName} ${person.lastName}`);
            return circle;
        }
        
        function createPersonElement(person) {
            const r = person.size;
            
            // Create group
            const g = document.createElementNS(elements.svg.namespaceURI, 'g');
            g.setAttribute('data-person-id', person.id);
            g.setAttribute('class', 'person-group');
            
            // Create circle
            const circle = document.createElementNS(elements.svg.namespaceURI, 'circle');
            circle.setAttribute('cx', person.x);
            circle.setAttribute('cy', person.y);
            circle.setAttribute('r', r);
            circle.setAttribute('fill', person.color);
            circle.setAttribute('class', 'person');
            circle.dataset.personId = person.id;
            
            // Create name text
            const nameText = document.createElementNS(elements.svg.namespaceURI, 'text');
            nameText.setAttribute('x', person.x);
            nameText.setAttribute('y', person.y - 5);
            nameText.setAttribute('class', 'name');
            nameText.setAttribute('font-family', state.globalFont);
            nameText.setAttribute('font-size', state.globalFontSize);
            nameText.textContent = `${person.firstName} ${person.lastName}`;
            
            // Create date text
            const dateText = document.createElementNS(elements.svg.namespaceURI, 'text');
            dateText.setAttribute('x', person.x);
            dateText.setAttribute('y', person.y + 15);
            dateText.setAttribute('class', 'date');
            dateText.setAttribute('font-family', state.globalFont);
            dateText.setAttribute('font-size', Math.max(8, state.globalFontSize - 2));
            dateText.textContent = person.birthDate ? new Date(person.birthDate).getFullYear() : '';
            
            // Add to group
            g.appendChild(circle);
            g.appendChild(nameText);
            g.appendChild(dateText);
            
            // Add to SVG
            elements.svg.appendChild(g);
            
            // Store references
            circle._group = g;
            circle._nameText = nameText;
            circle._dateText = dateText;
            
            // Add event listeners
            circle.addEventListener('click', (e) => handlePersonClick(e, circle));
            circle.addEventListener('dblclick', (e) => {
                e.stopPropagation();
                openPersonModal(circle);
            });
            
            // Setup drag
            setupDrag(circle);
            
            return circle;
        }
        
        function updatePerson(circle, data) {
            const person = state.people.get(circle.dataset.personId);
            Object.assign(person, data);
            
            // Update visual elements
            circle._nameText.textContent = `${data.firstName} ${data.lastName}`;
            circle._dateText.textContent = data.birthDate ? new Date(data.birthDate).getFullYear() : '';
            
            console.log(`✅ Person updated: ${data.firstName} ${data.lastName}`);
        }
        
        function deletePerson(circle) {
            const personId = circle.dataset.personId;
            console.log('Deleting person:', personId);
            
            // Remove from data
            state.people.delete(personId);
            
            // Remove relationships
            state.relationships.forEach((rel, id) => {
                if (rel.personA === personId || rel.personB === personId) {
                    state.relationships.delete(id);
                    // Remove visual line
                    const line = elements.svg.querySelector(`line[data-rel-id="${id}"]`);
                    if (line) line.remove();
                }
            });
            
            // Remove visual element
            circle._group.remove();
            
            clearSelection();
            updateStatusBar();
            pushHistory();
            showToast('Person deleted', 'success');
        }
        
        // =============================================================================
        // INTERACTION HANDLERS
        // =============================================================================
        
        function handlePersonClick(e, circle) {
            e.stopPropagation();
            console.log('Person clicked:', circle.dataset.personId);
            
            if (state.connectMode) {
                if (!state.selected) {
                    selectPerson(circle);
                } else if (state.selected !== circle) {
                    createConnection(state.selected, circle);
                    clearSelection();
                    toggleConnectMode();
                }
            } else {
                selectPerson(circle);
            }
        }
        
        function selectPerson(circle) {
            console.log('Selecting person:', circle.dataset.personId);
            
            clearSelection();
            
            state.selected = circle;
            circle.classList.add('selected');
            
            // Enable controls
            elements.editBtn.disabled = false;
            elements.deleteBtn.disabled = false;
            elements.colorPicker.disabled = false;
            elements.sizeInput.disabled = false;
            elements.applyBtn.disabled = false;
            
            // Update controls with current values
            const person = state.people.get(circle.dataset.personId);
            elements.colorPicker.value = person.color;
            elements.sizeInput.value = person.size;
            
            updateStatusBar();
        }
        
        function clearSelection() {
            if (state.selected) {
                state.selected.classList.remove('selected');
                state.selected = null;
            }
            
            // Disable controls
            elements.editBtn.disabled = true;
            elements.deleteBtn.disabled = true;
            elements.colorPicker.disabled = true;
            elements.sizeInput.disabled = true;
            elements.applyBtn.disabled = true;
            
            updateStatusBar();
        }
        
        function toggleConnectMode() {
            state.connectMode = !state.connectMode;
            elements.connectBtn.textContent = state.connectMode ? '❌ Cancel' : '🔗 Connect';
            elements.connectBtn.style.background = state.connectMode ? 
                'linear-gradient(135deg, #e74c3c 0%, #c0392b 100%)' : 
                'linear-gradient(135deg, #f39c12 0%, #e67e22 100%)';
            elements.svg.style.cursor = state.connectMode ? 'crosshair' : 'default';
            
            if (!state.connectMode) {
                clearSelection();
            }
            
            showToast(state.connectMode ? 'Click two people to connect them' : 'Connect mode disabled', 'info');
        }
        
        function applyChanges() {
            if (!state.selected) return;
            
            const person = state.people.get(state.selected.dataset.personId);
            person.color = elements.colorPicker.value;
            person.size = parseInt(elements.sizeInput.value);
            
            state.selected.setAttribute('fill', person.color);
            state.selected.setAttribute('r', person.size);
            
            pushHistory();
            showToast('Changes applied successfully!', 'success');
        }
        
        // =============================================================================
        // CONNECTIONS
        // =============================================================================
        
        function createConnection(circleA, circleB) {
            const relationshipId = 'rel_' + Date.now();
            const x1 = parseFloat(circleA.getAttribute('cx'));
            const y1 = parseFloat(circleA.getAttribute('cy'));
            const x2 = parseFloat(circleB.getAttribute('cx'));
            const y2 = parseFloat(circleB.getAttribute('cy'));
            
            console.log('Creating connection between:', circleA.dataset.personId, 'and', circleB.dataset.personId);
            
            // Store relationship
            state.relationships.set(relationshipId, {
                id: relationshipId,
                personA: circleA.dataset.personId,
                personB: circleB.dataset.personId
            });
            
            // Create visual line
            const line = document.createElementNS(elements.svg.namespaceURI, 'line');
            line.setAttribute('x1', x1);
            line.setAttribute('y1', y1);
            line.setAttribute('x2', x2);
            line.setAttribute('y2', y2);
            line.setAttribute('class', 'relation');
            line.setAttribute('data-rel-id', relationshipId);
            
            // Insert before people (so lines appear behind)
            const firstPerson = elements.svg.querySelector('.person-group');
            if (firstPerson) {
                elements.svg.insertBefore(line, firstPerson);
            } else {
                elements.svg.appendChild(line);
            }
            
            // Add click to delete
            line.addEventListener('click', (e) => {
                e.stopPropagation();
                if (confirm('Delete this relationship?')) {
                    state.relationships.delete(relationshipId);
                    line.remove();
                    updateStatusBar();
                    pushHistory();
                    showToast('Relationship deleted', 'success');
                }
            });
            
            updateStatusBar();
            pushHistory();
            showToast('Connection created successfully!', 'success');
        }
        
        // =============================================================================
        // DRAG AND DROP
        // =============================================================================
        
        function setupDrag(circle) {
            let isDragging = false;
            let startPos = null;
            
            circle.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', doDrag);
            document.addEventListener('mouseup', endDrag);
            
            // Touch events
            circle.addEventListener('touchstart', startDrag, { passive: false });
            document.addEventListener('touchmove', doDrag, { passive: false });
            document.addEventListener('touchend', endDrag);
            
            function startDrag(e) {
                e.stopPropagation();
                isDragging = true;
                
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                
                startPos = { x: clientX, y: clientY };
                circle.style.cursor = 'grabbing';
            }
            
            function doDrag(e) {
                if (!isDragging) return;
                e.preventDefault();
                
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                
                const dx = (clientX - startPos.x) * (state.viewBox.w / elements.svg.clientWidth);
                const dy = (clientY - startPos.y) * (state.viewBox.h / elements.svg.clientHeight);
                
                const newX = parseFloat(circle.getAttribute('cx')) + dx;
                const newY = parseFloat(circle.getAttribute('cy')) + dy;
                
                // Update circle position
                circle.setAttribute('cx', newX);
                circle.setAttribute('cy', newY);
                
                // Update text positions
                circle._nameText.setAttribute('x', newX);
                circle._nameText.setAttribute('y', newY - 5);
                circle._dateText.setAttribute('x', newX);
                circle._dateText.setAttribute('y', newY + 15);
                
                // Update connected lines
                updateConnectedLines(circle);
                
                startPos = { x: clientX, y: clientY };
            }
            
            function endDrag() {
                if (isDragging) {
                    isDragging = false;
                    circle.style.cursor = 'grab';
                    
                    // Update person data
                    const person = state.people.get(circle.dataset.personId);
                    person.x = parseFloat(circle.getAttribute('cx'));
                    person.y = parseFloat(circle.getAttribute('cy'));
                    
                    pushHistory();
                }
            }
        }
        
        function updateConnectedLines(circle) {
            const personId = circle.dataset.personId;
            
            state.relationships.forEach((rel, id) => {
                if (rel.personA === personId || rel.personB === personId) {
                    const line = elements.svg.querySelector(`line[data-rel-id="${id}"]`);
                    if (line) {
                        if (rel.personA === personId) {
                            line.setAttribute('x1', circle.getAttribute('cx'));
                            line.setAttribute('y1', circle.getAttribute('cy'));
                        } else {
                            line.setAttribute('x2', circle.getAttribute('cx'));
                            line.setAttribute('y2', circle.getAttribute('cy'));
                        }
                    }
                }
            });
        }
        
        // =============================================================================
        // PAN AND ZOOM
        // =============================================================================
        
        function setupPanAndZoom() {
            let isPanning = false;
            let startPoint = null;
            
            // Mouse wheel zoom
            elements.svg.addEventListener('wheel', (e) => {
                e.preventDefault();
                const scale = e.deltaY < 0 ? 0.9 : 1.1;
                
                const rect = elements.svg.getBoundingClientRect();
                const mx = ((e.clientX - rect.left) / rect.width) * state.viewBox.w + state.viewBox.x;
                const my = ((e.clientY - rect.top) / rect.height) * state.viewBox.h + state.viewBox.y;
                
                const newW = state.viewBox.w * scale;
                const newH = state.viewBox.h * scale;
                
                if (newW > 50 && newW < 5000) {
                    state.viewBox.x = mx - (mx - state.viewBox.x) * scale;
                    state.viewBox.y = my - (my - state.viewBox.y) * scale;
                    state.viewBox.w = newW;
                    state.viewBox.h = newH;
                    updateViewBox();
                }
            }, { passive: false });
            
            // Mouse pan
            elements.svg.addEventListener('mousedown', (e) => {
                if (e.target === elements.svg || e.target.classList.contains('grid-line')) {
                    isPanning = true;
                    startPoint = { x: e.clientX, y: e.clientY };
                    elements.svg.style.cursor = 'grabbing';
                }
            });
            
            document.addEventListener('mousemove', (e) => {
                if (isPanning) {
                    const dx = (startPoint.x - e.clientX) * (state.viewBox.w / elements.svg.clientWidth);
                    const dy = (startPoint.y - e.clientY) * (state.viewBox.h / elements.svg.clientHeight);
                    
                    state.viewBox.x += dx;
                    state.viewBox.y += dy;
                    updateViewBox();
                    
                    startPoint = { x: e.clientX, y: e.clientY };
                }
            });
            
            document.addEventListener('mouseup', () => {
                isPanning = false;
                elements.svg.style.cursor = 'default';
            });
            
            // Touch support
            let lastTouchDistance = 0;
            
            elements.svg.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    lastTouchDistance = getTouchDistance(e.touches);
                } else if (e.touches.length === 1 && e.target === elements.svg) {
                    isPanning = true;
                    startPoint = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                }
            }, { passive: false });
            
            elements.svg.addEventListener('touchmove', (e) => {
                e.preventDefault();
                
                if (e.touches.length === 2) {
                    // Pinch zoom
                    const currentDistance = getTouchDistance(e.touches);
                    const scale = lastTouchDistance / currentDistance;
                    
                    if (scale > 0.5 && scale < 2) {
                        const newW = state.viewBox.w * scale;
                        const newH = state.viewBox.h * scale;
                        
                        if (newW > 50 && newW < 5000) {
                            const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                            const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                            
                            const rect = elements.svg.getBoundingClientRect();
                            const mx = ((centerX - rect.left) / rect.width) * state.viewBox.w + state.viewBox.x;
                            const my = ((centerY - rect.top) / rect.height) * state.viewBox.h + state.viewBox.y;
                            
                            state.viewBox.x = mx - (mx - state.viewBox.x) * scale;
                            state.viewBox.y = my - (my - state.viewBox.y) * scale;
                            state.viewBox.w = newW;
                            state.viewBox.h = newH;
                            updateViewBox();
                        }
                    }
                    
                    lastTouchDistance = currentDistance;
                } else if (e.touches.length === 1 && isPanning) {
                    // Pan
                    const dx = (startPoint.x - e.touches[0].clientX) * (state.viewBox.w / elements.svg.clientWidth);
                    const dy = (startPoint.y - e.touches[0].clientY) * (state.viewBox.h / elements.svg.clientHeight);
                    
                    state.viewBox.x += dx;
                    state.viewBox.y += dy;
                    updateViewBox();
                    
                    startPoint = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                }
            }, { passive: false });
            
            elements.svg.addEventListener('touchend', () => {
                isPanning = false;
            });
            
            function getTouchDistance(touches) {
                const dx = touches[0].clientX - touches[1].clientX;
                const dy = touches[0].clientY - touches[1].clientY;
                return Math.sqrt(dx * dx + dy * dy);
            }
        }
        
        // =============================================================================
        // SEARCH FUNCTIONALITY
        // =============================================================================
        
        function performSearch(query) {
            clearSearch();
            
            if (!query.trim()) return;
            
            const searchTerms = query.toLowerCase().split(' ');
            const matches = [];
            
            state.people.forEach((person, id) => {
                const searchText = [
                    person.firstName,
                    person.lastName,
                    person.birthPlace,
                    person.occupation,
                    person.notes
                ].join(' ').toLowerCase();
                
                const isMatch = searchTerms.every(term => searchText.includes(term));
                
                if (isMatch) {
                    matches.push(id);
                    state.searchMatches.add(id);
                    
                    // Highlight person
                    const circle = elements.svg.querySelector(`circle[data-person-id="${id}"]`);
                    if (circle) {
                        circle.style.stroke = '#f39c12';
                        circle.style.strokeWidth = '3px';
                    }
                }
            });
            
            if (matches.length > 0) {
                showToast(`Found ${matches.length} match${matches.length !== 1 ? 'es' : ''}`, 'success');
                
                // Center on first match
                const firstMatch = state.people.get(matches[0]);
                if (firstMatch) {
                    state.viewBox.x = firstMatch.x - state.viewBox.w / 2;
                    state.viewBox.y = firstMatch.y - state.viewBox.h / 2;
                    updateViewBox();
                }
            } else {
                showToast('No matches found', 'warning');
            }
            
            updateStatusBar();
        }
        
        function clearSearch() {
            elements.searchInput.value = '';
            
            state.searchMatches.forEach(personId => {
                const circle = elements.svg.querySelector(`circle[data-person-id="${personId}"]`);
                if (circle) {
                    circle.style.stroke = '';
                    circle.style.strokeWidth = '';
                }
            });
            
            state.searchMatches.clear();
            updateStatusBar();
        }
        
        // =============================================================================
        // UTILITY FUNCTIONS
        // =============================================================================
        
        function centerView() {
            if (state.people.size === 0) {
                showToast('No people to center on', 'warning');
                return;
            }
            
            const people = Array.from(state.people.values());
            let avgX = 0, avgY = 0;
            
            people.forEach(person => {
                avgX += person.x;
                avgY += person.y;
            });
            
            avgX /= people.length;
            avgY /= people.length;
            
            state.viewBox.x = avgX - state.viewBox.w / 2;
            state.viewBox.y = avgY - state.viewBox.h / 2;
            updateViewBox();
            
            showToast('Centered on family tree', 'success');
        }
        
        function updateStatusBar() {
            document.getElementById('peopleCount').textContent = `${state.people.size} people`;
            document.getElementById('relationshipsCount').textContent = `${state.relationships.size} relationships`;
            
            if (state.selected) {
                const person = state.people.get(state.selected.dataset.personId);
                document.getElementById('selectedInfo').textContent = `Selected: ${person.firstName} ${person.lastName}`;
            } else if (state.searchMatches.size > 0) {
                document.getElementById('selectedInfo').textContent = `${state.searchMatches.size} search matches`;
            } else {
                document.getElementById('selectedInfo').textContent = 'No selection';
            }
        }
        
        function updateZoomLevel() {
            const zoomPercent = Math.round((800 / state.viewBox.w) * 100);
            document.getElementById('zoomLevel').textContent = `${zoomPercent}%`;
        }
        
        function pushHistory() {
            const historyState = {
                people: Array.from(state.people.entries()),
                relationships: Array.from(state.relationships.entries()),
                viewBox: { ...state.viewBox }
            };
            
            state.history.push(JSON.stringify(historyState));
            if (state.history.length > 20) state.history.shift();
            
            elements.undoBtn.disabled = false;
        }
        
        function undo() {
            if (state.history.length === 0) return;
            
            const prevState = JSON.parse(state.history.pop());
            
            console.log('Undoing to previous state');
            
            // Clear current state
            elements.svg.innerHTML = '';
            state.people.clear();
            state.relationships.clear();
            clearSelection();
            
            // Restore background
            createBackground();
            
            // Restore people
            prevState.people.forEach(([id, person]) => {
                state.people.set(id, person);
                state.personCount = Math.max(state.personCount, parseInt(id.replace('person_', '')) || 0);
                createPersonElement(person);
            });
            
            // Restore relationships
            prevState.relationships.forEach(([id, rel]) => {
                state.relationships.set(id, rel);
                const circleA = elements.svg.querySelector(`circle[data-person-id="${rel.personA}"]`);
                const circleB = elements.svg.querySelector(`circle[data-person-id="${rel.personB}"]`);
                
                if (circleA && circleB) {
                    const line = document.createElementNS(elements.svg.namespaceURI, 'line');
                    line.setAttribute('x1', circleA.getAttribute('cx'));
                    line.setAttribute('y1', circleA.getAttribute('cy'));
                    line.setAttribute('x2', circleB.getAttribute('cx'));
                    line.setAttribute('y2', circleB.getAttribute('cy'));
                    line.setAttribute('class', 'relation');
                    line.setAttribute('data-rel-id', id);
                    
                    const firstPerson = elements.svg.querySelector('.person-group');
                    if (firstPerson) {
                        elements.svg.insertBefore(line, firstPerson);
                    } else {
                        elements.svg.appendChild(line);
                    }
                    
                    line.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (confirm('Delete this relationship?')) {
                            state.relationships.delete(id);
                            line.remove();
                            updateStatusBar();
                            pushHistory();
                            showToast('Relationship deleted', 'success');
                        }
                    });
                }
            });
            
            // Restore view
            state.viewBox = prevState.viewBox;
            updateViewBox();
            
            updateStatusBar();
            
            if (state.history.length === 0) {
                elements.undoBtn.disabled = true;
            }
            
            showToast('Undone', 'info');
        }
        
        // =============================================================================
        // FONT CONTROLS
        // =============================================================================
        
        function updateGlobalFont() {
            state.globalFont = elements.fontSelect.value;
            console.log('Updating global font to:', state.globalFont);
            
            // Update all existing text elements
            elements.svg.querySelectorAll('text').forEach(text => {
                text.setAttribute('font-family', state.globalFont);
            });
            
            showToast('Font updated!', 'success');
        }
        
        function updateGlobalFontSize() {
            const newSize = parseInt(elements.fontSizeInput.value);
            if (newSize >= 8 && newSize <= 24) {
                state.globalFontSize = newSize;
                console.log('Updating global font size to:', state.globalFontSize);
                
                // Update all existing text elements
                elements.svg.querySelectorAll('text.name').forEach(text => {
                    text.setAttribute('font-size', state.globalFontSize);
                });
                
                elements.svg.querySelectorAll('text.date').forEach(text => {
                    text.setAttribute('font-size', Math.max(8, state.globalFontSize - 2));
                });
                
                showToast('Font size updated!', 'success');
            }
        }
        
        // =============================================================================
        // ENHANCED EXPORT FUNCTIONS
        // =============================================================================
        
        function exportPNG() {
            if (state.people.size === 0) {
                showToast('No family tree to export', 'warning');
                return;
            }
            
            console.log('Exporting as PNG...');
            showToast('Generating PNG export...', 'info');
            
            const svgElement = prepareExportSVG();
            
            // Create a canvas to render the SVG
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Calculate export dimensions
            const bounds = calculateBounds();
            const scale = 2; // High DPI
            canvas.width = bounds.w * scale;
            canvas.height = bounds.h * scale;
            
            // Create an image from SVG
            const svgBlob = new Blob([new XMLSerializer().serializeToString(svgElement)], 
                { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(svgBlob);
            
            const img = new Image();
            img.onload = function() {
                // Fill background with white
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw the SVG image
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                
                // Convert to PNG and download
                canvas.toBlob(function(blob) {
                    const downloadUrl = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = downloadUrl;
                    a.download = `family-tree-${new Date().toISOString().split('T')[0]}.png`;
                    a.click();
                    
                    URL.revokeObjectURL(downloadUrl);
                    URL.revokeObjectURL(url);
                    showToast('PNG exported successfully!', 'success');
                }, 'image/png', 0.95);
            };
            
            img.onerror = function() {
                URL.revokeObjectURL(url);
                showToast('Failed to export PNG', 'error');
            };
            
            img.src = url;
        }
        
        function exportPDF() {
            if (state.people.size === 0) {
                showToast('No family tree to export', 'warning');
                return;
            }
            
            // Check if jsPDF is available
            if (typeof window.jspdf === 'undefined') {
                showToast('Loading PDF library...', 'info');
                
                // Load jsPDF dynamically
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
                script.onload = function() {
                    console.log('jsPDF loaded successfully');
                    exportPDF(); // Retry after loading
                };
                script.onerror = function() {
                    showToast('Failed to load PDF library', 'error');
                };
                document.head.appendChild(script);
                return;
            }
            
            console.log('Exporting as PDF...');
            showToast('Generating PDF export...', 'info');
            
            const bounds = calculateBounds();
            const svgElement = prepareExportSVG();
            
            // Create canvas for PDF
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size
            const scale = 2;
            canvas.width = bounds.w * scale;
            canvas.height = bounds.h * scale;
            
            const svgBlob = new Blob([new XMLSerializer().serializeToString(svgElement)], 
                { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(svgBlob);
            
            const img = new Image();
            img.onload = function() {
                // Fill background
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                
                try {
                    const { jsPDF } = window.jspdf;
                    
                    // Calculate PDF dimensions (convert to points, 72 DPI)
                    const pdfWidth = (bounds.w * 72) / 96;
                    const pdfHeight = (bounds.h * 72) / 96;
                    
                    const pdf = new jsPDF({
                        orientation: pdfWidth > pdfHeight ? 'landscape' : 'portrait',
                        unit: 'pt',
                        format: [pdfWidth, pdfHeight],
                        compress: true
                    });
                    
                    const dataUrl = canvas.toDataURL('image/png', 0.95);
                    pdf.addImage(dataUrl, 'PNG', 0, 0, pdfWidth, pdfHeight, undefined, 'FAST');
                    
                    // Add metadata
                    pdf.setProperties({
                        title: 'Family Tree',
                        subject: 'Generated by Family Tree Builder Pro',
                        author: 'Family Tree Builder Pro',
                        creator: 'Family Tree Builder Pro'
                    });
                    
                    const filename = `family-tree-${new Date().toISOString().split('T')[0]}.pdf`;
                    pdf.save(filename);
                    
                    URL.revokeObjectURL(url);
                    showToast('PDF exported successfully!', 'success');
                    
                } catch (error) {
                    console.error('PDF export error:', error);
                    URL.revokeObjectURL(url);
                    showToast('Failed to export PDF', 'error');
                }
            };
            
            img.onerror = function() {
                URL.revokeObjectURL(url);
                showToast('Failed to export PDF', 'error');
            };
            
            img.src = url;
        }
        
        function calculateBounds() {
            const people = Array.from(state.people.values());
            if (people.length === 0) return { x: 0, y: 0, w: 800, h: 600 };
            
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            
            people.forEach(person => {
                const r = person.size;
                minX = Math.min(minX, person.x - r);
                minY = Math.min(minY, person.y - r);
                maxX = Math.max(maxX, person.x + r);
                maxY = Math.max(maxY, person.y + r);
            });
            
            const margin = 40;
            return {
                x: minX - margin,
                y: minY - margin,
                w: maxX - minX + 2 * margin,
                h: maxY - minY + 2 * margin
            };
        }
        
        function prepareExportSVG() {
            // Clone the SVG
            const svgClone = elements.svg.cloneNode(true);
            
            // Remove grid lines and selected states
            svgClone.querySelectorAll('.grid-line').forEach(line => line.remove());
            svgClone.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
            
            // Calculate bounds and set viewBox
            const bounds = calculateBounds();
            svgClone.setAttribute('viewBox', `${bounds.x} ${bounds.y} ${bounds.w} ${bounds.h}`);
            svgClone.setAttribute('width', bounds.w);
            svgClone.setAttribute('height', bounds.h);
            svgClone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
            
            // Add embedded styles
            const style = document.createElementNS(elements.svg.namespaceURI, 'style');
            style.textContent = `
                circle.person { 
                    stroke: none; 
                    filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.2));
                }
                text.name { 
                    font-weight: bold; 
                    fill: #2c3e50; 
                    text-anchor: middle;
                    text-shadow: 1px 1px 2px rgba(255,255,255,0.8);
                }
                text.date { 
                    fill: #7f8c8d; 
                    text-anchor: middle;
                    font-style: italic;
                }
                line.relation { 
                    stroke: #555; 
                    stroke-width: 3; 
                    stroke-linecap: round;
                    filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.1));
                }
            `;
            svgClone.insertBefore(style, svgClone.firstChild);
            
            return svgClone;
        }
        
        function saveTree() {
            const data = {
                people: Array.from(state.people.entries()),
                relationships: Array.from(state.relationships.entries()),
                viewBox: state.viewBox,
                settings: {
                    globalFont: state.globalFont,
                    globalFontSize: state.globalFontSize
                },
                metadata: {
                    version: '2.1',
                    exportDate: new Date().toISOString(),
                    peopleCount: state.people.size,
                    relationshipsCount: state.relationships.size
                }
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            
            a.href = url;
            a.download = `family-tree-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            
            URL.revokeObjectURL(url);
            showToast('Family tree saved successfully!', 'success');
        }
        
        function loadTree(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const data = JSON.parse(event.target.result);
                    
                    console.log('Loading family tree data:', data);
                    
                    // Clear current tree
                    elements.svg.innerHTML = '';
                    state.people.clear();
                    state.relationships.clear();
                    state.history = [];
                    clearSelection();
                    
                    // Restore background
                    createBackground();
                    
                    // Load people
                    data.people.forEach(([id, person]) => {
                        state.people.set(id, person);
                        state.personCount = Math.max(state.personCount, parseInt(id.replace('person_', '')) || 0);
                        createPersonElement(person);
                    });
                    
                    // Load relationships
                    data.relationships.forEach(([id, rel]) => {
                        state.relationships.set(id, rel);
                        const circleA = elements.svg.querySelector(`circle[data-person-id="${rel.personA}"]`);
                        const circleB = elements.svg.querySelector(`circle[data-person-id="${rel.personB}"]`);
                        
                        if (circleA && circleB) {
                            const line = document.createElementNS(elements.svg.namespaceURI, 'line');
                            line.setAttribute('x1', circleA.getAttribute('cx'));
                            line.setAttribute('y1', circleA.getAttribute('cy'));
                            line.setAttribute('x2', circleB.getAttribute('cx'));
                            line.setAttribute('y2', circleB.getAttribute('cy'));
                            line.setAttribute('class', 'relation');
                            line.setAttribute('data-rel-id', id);
                            
                            const firstPerson = elements.svg.querySelector('.person-group');
                            if (firstPerson) {
                                elements.svg.insertBefore(line, firstPerson);
                            } else {
                                elements.svg.appendChild(line);
                            }
                            
                            line.addEventListener('click', (e) => {
                                e.stopPropagation();
                                if (confirm('Delete this relationship?')) {
                                    state.relationships.delete(id);
                                    line.remove();
                                    updateStatusBar();
                                    pushHistory();
                                    showToast('Relationship deleted', 'success');
                                }
                            });
                        }
                    });
                    
                    // Restore view and settings
                    if (data.viewBox) {
                        state.viewBox = data.viewBox;
                        updateViewBox();
                    }
                    
                    if (data.settings) {
                        state.globalFont = data.settings.globalFont || 'Arial, sans-serif';
                        state.globalFontSize = data.settings.globalFontSize || 12;
                        elements.fontSelect.value = state.globalFont;
                        elements.fontSizeInput.value = state.globalFontSize;
                        
                        // Apply font settings to loaded elements
                        updateGlobalFont();
                        updateGlobalFontSize();
                    }
                    
                    updateStatusBar();
                    showToast(`Family tree loaded! ${state.people.size} people, ${state.relationships.size} relationships`, 'success');
                    
                } catch (error) {
                    console.error('Load error:', error);
                    showToast('Failed to load file. Please check the file format.', 'error');
                }
            };
            
            reader.readAsText(file);
            e.target.value = ''; // Reset file input
        }
        
        function exportSVG() {
            if (state.people.size === 0) {
                showToast('No family tree to export', 'warning');
                return;
            }
            
            console.log('Exporting as SVG...');
            
            const svgClone = prepareExportSVG();
            
            // Create download
            const svgStr = new XMLSerializer().serializeToString(svgClone);
            const blob = new Blob([svgStr], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            
            a.href = url;
            a.download = `family-tree-${new Date().toISOString().split('T')[0]}.svg`;
            a.click();
            
            URL.revokeObjectURL(url);
            showToast('SVG exported successfully!', 'success');
        }
        
        // =============================================================================
        // KEYBOARD SHORTCUTS
        // =============================================================================
        
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Don't interfere with form inputs
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
                    return;
                }
                
                switch (e.key) {
                    case 'Delete':
                    case 'Backspace':
                        if (state.selected && confirm('Delete this person?')) {
                            deletePerson(state.selected);
                        }
                        break;
                        
                    case 'Escape':
                        clearSelection();
                        if (state.connectMode) toggleConnectMode();
                        closePersonModal();
                        break;
                        
                    case ' ':
                        if (state.selected) {
                            e.preventDefault();
                            openPersonModal(state.selected);
                        }
                        break;
                }
                
                // Ctrl combinations
                if (e.ctrlKey || e.metaKey) {
                    switch (e.key) {
                        case 'z':
                            e.preventDefault();
                            undo();
                            break;
                        case 's':
                            e.preventDefault();
                            saveTree();
                            break;
                        case 'n':
                            e.preventDefault();
                            openPersonModal();
                            break;
                        case 'f':
                            e.preventDefault();
                            elements.searchInput.focus();
                            break;
                    }
                }
            });
        }
        
        // =============================================================================
        // TOAST NOTIFICATIONS
        // =============================================================================
        
        function showToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);
            
            // Trigger animation
            setTimeout(() => toast.classList.add('show'), 10);
            
            // Remove after delay
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 400);
            }, type === 'error' ? 5000 : 3000);
        }
        
        // =============================================================================
        // GLOBAL FUNCTIONS FOR DEBUGGING
        // =============================================================================
        
        window.familyTreeState = state;
        window.addTestPerson = () => {
            const testData = {
                firstName: 'Test',
                lastName: 'Person',
                birthDate: '1980-01-01',
                gender: 'unknown',
                birthPlace: 'Test City',
                occupation: 'Tester',
                notes: 'This is a test person created for debugging'
            };
            createPerson(testData);
            updateStatusBar();
            showToast('Test person added!', 'success');
        };
        window.closePersonModal = closePersonModal;
        
        // =============================================================================
        // INITIALIZATION
        // =============================================================================
        
        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>